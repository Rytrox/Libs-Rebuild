package de.timeout.libs.sql;

import org.jetbrains.annotations.NotNull;

import javax.sql.DataSource;
import java.sql.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.function.Function;

public class QueryBuilder {

    private final String query;
    private final DataSource source;
    private final Object[] args;

    public QueryBuilder(@NotNull DataSource source, @NotNull String query, Object... args) {
        this.query = query;
        this.args = args;
        this.source = source;
    }

    @NotNull
    private PreparedStatement prepareStatement(@NotNull Connection connection, @NotNull String statement, Object... args) throws SQLException {
        //Do not close this Statement here!!
        PreparedStatement ps = connection.prepareStatement(statement);
        if(args != null)
            for(int i = 0; i < args.length; i++) ps.setString(i +1, args[i].toString());
        return ps;
    }

    @NotNull
    private PreparedStatement preparedStatement(@NotNull Connection connection,
                                                @NotNull String statement,
                                                int autoGeneratedRows,
                                                Object... args) throws SQLException {
        PreparedStatement ps = connection.prepareStatement(statement, autoGeneratedRows);
        if(args != null)
            for(int i = 0; i < args.length; i++) ps.setString(i + 1, args[i].toString());

        return ps;
    }

    /**
     * Executes a SELECT-Statement which returns a table. <br>
     * This method runs asynchronously. <br>
     * The Bukkit API should run synchronously using a scheduler <br>
     *
     * @param result A function that is executed after the ResultSet is received.
     */
    public <T> CompletableFuture<T> query(@NotNull Function<ResultSet, T> result) {
        return CompletableFuture.supplyAsync(() -> {
            try(Connection connection = source.getConnection();
                PreparedStatement statement = prepareStatement(connection, query, args);
                ResultSet set = statement.executeQuery()) {

                return result.apply(set);
            } catch (SQLException exception) {
                throw new CompletionException(exception);
            }
        });
    }

    /**
     * Executes any MySQL-Statement <br>
     * This method runs asynchronously.
     *
     * @param result a function that is executed after the result bool is received
     */
    public CompletableFuture<Boolean> execute() {
        return CompletableFuture.supplyAsync(() -> {
            try(Connection connection = source.getConnection();
                PreparedStatement statement = prepareStatement(connection, query, args)) {

                return statement.execute();
            } catch (SQLException exception) {
                throw new CompletionException(exception);
            }
        });
    }

    /**
     * Executes a default INSERT-Statement. <br>
     * This method runs asynchronously.
     */
    public CompletableFuture<Integer> insert() {
        return CompletableFuture.supplyAsync(() -> {
            try(Connection connection = source.getConnection();
                PreparedStatement statement = prepareStatement(connection, query, args, Statement.RETURN_GENERATED_KEYS)) {
                statement.executeUpdate();

                ResultSet resultSet = statement.getGeneratedKeys();
                return resultSet.getInt(1);
            } catch (SQLException exception) {
                throw new CompletionException(exception);
            }
        });
    }

    /**
     * Executes a MySQL-Statement like UPDATE, DELETE etc.<br>
     * This method runs asynchronously.
     *
     * @param result A function that is executed after the integer result is received.
     */
    public CompletableFuture<Integer> update() {
        return CompletableFuture.supplyAsync(() -> {
            try(Connection connection = source.getConnection();
                PreparedStatement statement = prepareStatement(connection, query, args)) {

                return statement.executeUpdate();
            } catch (SQLException exception) {
                throw new CompletionException(exception);
            }
        });
    }
}
