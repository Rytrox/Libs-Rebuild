package de.timeout.libs.sql;

import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import javax.sql.DataSource;
import java.lang.reflect.Constructor;
import java.sql.*;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.*;

public record QueryBuilder(DataSource source, String query, Object... args) {

    public QueryBuilder(@NotNull DataSource source, @NotNull String query, Object... args) {
        this.query = query;
        this.args = args;
        this.source = source;
    }

    @NotNull
    private PreparedStatement prepareStatement(@NotNull Connection connection, @NotNull String statement, Object... args) throws SQLException {
        //Do not close this Statement here!!
        PreparedStatement ps = connection.prepareStatement(statement);
        if(args != null)
            for(int i = 0; i < args.length; i++) ps.setString(i + 1, args[i].toString());
        return ps;
    }

    @NotNull
    private <T> List<T> convertResultSetToEntities(@NotNull Class<T> targetClass,
                                                   @NotNull ResultSet resultSet) throws ReflectiveOperationException, SQLException {
        Constructor<T> constructor = targetClass.getConstructor(ResultSet.class);
        List<T> entities = new LinkedList<>();

        while(resultSet.next()) {
            entities.add(constructor.newInstance(resultSet));
        }

        return entities;
    }

    /**
     * Executes a SELECT-Statement which returns a table. <br>
     * This method runs asynchronously. <br>
     * The Bukkit API should run synchronously using a scheduler <br>
     *
     * @param targetClass the mapped EntityClass
     */
    @NotNull
    public <T> QueryResult<T> queryAsync(Class<T> targetClass) {
        CompletableFuture<List<T>> future = CompletableFuture.supplyAsync(() -> {
            try(Connection connection = source.getConnection();
                PreparedStatement statement = prepareStatement(connection, query, args)) {

                return convertResultSetToEntities(targetClass, statement.executeQuery());
            } catch (SQLException | ReflectiveOperationException exception) {
                throw new CompletionException(exception);
            }
        });

        return new AsyncQueryResult<>(future);
    }

    /**
     * Executes a SELECT-Statement which returns a table. <br>
     * This method runs sync with Bukkit-API and is safe to use.
     *
     * @param targetClass the mapped Entity Class
     */
    @Contract("_ -> new")
    public <T> @NotNull QueryResult<T> query(Class<T> targetClass) {
        try(Connection connection = source.getConnection();
            PreparedStatement statement = prepareStatement(connection, query, args)) {

            return new SyncQueryResult<>(convertResultSetToEntities(targetClass, statement.executeQuery()));
        } catch (SQLException | ReflectiveOperationException exception) {
            throw new IllegalStateException("Cannot execute SQL-Statement. Inner exception was: " + exception);
        }
    }

    /**
     * Executes any MySQL-Statement <br>
     * This method runs asynchronously.
     *
     * @return a CompletableFuture that returns the result if the statement succeed
     */
    @Contract(" -> new")
    public @NotNull CompletableFuture<Boolean> executeAsync() {
        return CompletableFuture.supplyAsync(() -> {
            try(Connection connection = source.getConnection();
                PreparedStatement statement = prepareStatement(connection, query, args)) {

                return statement.execute();
            } catch (SQLException exception) {
                throw new CompletionException(exception);
            }
        });
    }

    /**
     * Executes any SQL-Statement <br>
     * This method runs sync with the Bukkit-API
     *
     * @return true if the statement was successfully executed, false otherwise
     */
    public boolean execute() {
        try(Connection connection = source.getConnection();
            PreparedStatement statement = prepareStatement(connection, query, args)) {

            return statement.execute();
        } catch (SQLException e) {
            throw new IllegalStateException("Could not execute SQL-Statement. Inner exception was: " + e);
        }
    }


    /**
     * Executes a default INSERT-Statement. <br>
     * This method runs asynchronously.
     */
    @Contract(" -> new")
    public @NotNull CompletableFuture<Integer> insertAsync() {
        return insertAsync(false);
    }

    /**
     * Executes a default INSERT-Statement. <br>
     * This method runs asynchronously.
     */
    public @NotNull CompletableFuture<Integer> insertAsync(boolean returnAutoGeneratedValue) {
        return CompletableFuture.supplyAsync(() -> {
            try(Connection connection = source.getConnection();
                PreparedStatement statement = returnAutoGeneratedValue ?
                        prepareStatement(connection, query, args, Statement.RETURN_GENERATED_KEYS) :
                        prepareStatement(connection, query, args)) {

                if(returnAutoGeneratedValue) {
                    statement.executeUpdate();

                    ResultSet resultSet = statement.getGeneratedKeys();
                    return resultSet.getInt(1);
                } else return statement.executeUpdate();
            } catch (SQLException exception) {
                throw new CompletionException(exception);
            }
        });
    }
    /**
     * Executes a default INSERT-Statement. <br>
     * If you are using a generated key in your table, this method will return this key.
     *
     * @return the generated key of your table. Otherwise, ignore it
     */
    public int insert(boolean returnAutoGeneratedValue) {
        try(Connection connection = source.getConnection();
            PreparedStatement statement = prepareStatement(connection, query, args, Statement.RETURN_GENERATED_KEYS)) {
            statement.executeUpdate();

            return statement.getGeneratedKeys().getInt(1);
        } catch (SQLException e) {
            throw new IllegalStateException("Could not execute SQL-Statement. Inner exception was: " + e);
        }
    }

    /**
     * Executes a MySQL-Statement like UPDATE, DELETE etc.<br>
     * This method runs asynchronously.
     *
     * @return a CompletableFuture that returns the result if the statement succeed
     */
    @Contract(" -> new")
    public @NotNull CompletableFuture<Integer> updateAsync() {
        return CompletableFuture.supplyAsync(() -> {
            try(Connection connection = source.getConnection();
                PreparedStatement statement = prepareStatement(connection, query, args)) {

                return statement.executeUpdate();
            } catch (SQLException exception) {
                throw new CompletionException(exception);
            }
        });
    }

    /**
     * Executes a MySQL-Statement like UPDATE, DELETE etc.<br>
     * This method runs sync with Bukkit-API.
     *
     * @return the row count of manipulations inside MySQL
     */
    public int update() {
        try(Connection connection = source.getConnection();
            PreparedStatement statement = prepareStatement(connection, query, args)) {
            return statement.executeUpdate();
        } catch (SQLException e) {
            throw new IllegalStateException("Could not execute SQL-Statement. Inner exception was: " + e);
        }
    }
}
